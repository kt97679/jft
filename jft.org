# -*- mode: org; fill-column: 60; -*-
#+STARTUP: showall indent hidestars

#+TITLE: JFT programming language

* Introduction

Опираясь на множество чужих и некоторые собственные идеи, я
бы хотел немного "переизобрести IT с нуля".

Драйвером этой работы является возрастающая сложность
программирования и инструментария для него, в то время как
идеи остаются простыми.

Из-за сложности, в частности, затрудняется обучение
программированию, а от него зависит устойчивость нашей
IT-инфраструктуры.

Эта устойчивость важна, потому что от нее зависит
практически все в современном мире, в том числе и жизни
людей.

Поэтому, цель этого проекта:
- создать "понимаемую" систему, чтобы она могла уместиться в
  голове одного человека, разрабатываться и поддерживаться в
  одиночку или небольшой группой с хорошим соотношением
  вложенных усилий к получаемому результату
- при этом поддерживающую все основные концепции
  программирования и показывающую границы их применимости
- расширяемую без потери функциональной стройности, с
  возможностью "выкинуть все ненужное" при реализации
  конкретной задачи
- кроссплатформенную, отвязанную не только от операционных
  систем, но и от архитектуры машины, насколько это возможно
- способную быть не только проектом для обучения, но и
  полезной платформой для "взрослых" применений.

Следуя за идеями Aлана Кея, я вижу путь к реализации этой
идеи через создание языков предметной области (Domain
Specific Languages - DSL) и удобной среды для их разработки.

Для этого надо построить эту среду "снизу-вверх", начиная с
уровня ~абстрактного ассемблера~, через ~стековую машину~, к
~хост-языку~, который станет базой для разработки ~языков
предметной области~, предназначенных для решения конкретных
задач.

Возможные целевые задачи (неполный список, просто для
иллюстрации):
- управляющие программы (от светофора до операционных
  систем)
- пользовательские интерфейсы (от теминала до оконной
  оболочки)
- коммуникационные приложения (от чата до видеотелефонии)
- системы управления базами данных
- компютерные игры
- средства программирования (редакторы, отладчики,
  компиляторы, визуализаторы, верификаторы программ)
- распределенные приложения (блокчейн-системы,
  смарт-контракты)

* START Abstract assembler

Первый шаг - создание "абстрактного ассемблера", который
может выглядеть так:

#+BEGIN_SRC asm
      mov     %IPR, %ACR     # another comment
      # some comment
  _label:
      mov     (%IPR), %ACR
      jmp     _label
#+END_SRC

В этом ассемблере используются "абстрактные регистры",
которые потом будут сопоставлены с "конкретными регистрами"
каждой целевой архитектуры. Например регистр %ACR может
превратиться в RAX на x86_64, а на микроконтроллере AVR - в
восьмибитный регистр r1.

Таким образом, не делая предположения о разрядности
регистров и других платформозависмых вещах, от каждой
целевой машины нам требуется:
- минимальный набор регистров
- стек
- память
- возможность передачи управления

Чтобы удобнее работать с абстрактным ассемблером,
преобразуем его в форму, где каждой команде соответствует
список:

#+BEGIN_SRC elisp
  ((:cmd :mov_reg_to_reg  :from "%IPR" :to "%ACR")
   (:comment-line "# some comment")
   (:cmd :label :name "_label")
   (:cmd :mov_mem_to_reg :from "%IPR" :to "%ACR")
   (:cmd :jmp_label :to "_label" :rest))
#+END_SRC

Теперь удобно заменить "абстрактные регистры" на "конкретные
регистры" и проводить оптимизационные преобразования,
например переставлять команды или заменять несколько команд
на одну.

Когда все преобразования проведены, можно ассемблировать в
машинный код целевой платформы и построить исполняемый
файл. На этом этапе нужно вычислить конкретные значения
смещения и меток, т.е. выполнить работу ассемблера.

Эта работа описана здесь: [[file:aasm.org][Abstract Assembler]]

От каждой платформы нам необходимы не все команды, а только
минимальный набор, который обеспечит построение минимальный
форт-машины - первого платформо-независимого слоя
архитектуры.

* Minimal Forth Machine

Далее на абстрактном ассемблере мы пишем минимальную
форт-машину, чтобы уже на ней написать все остальное.

Эта форт машина ограничивается самым компактным
подмножеством форта:
- словарь в коссвенном шитом коде
- подключаемые словари
- стек возвратов и стек данных
- литералы
- доступ к памяти
- ввод и вывод
- компиляция и создание слов
- INTERPRET
- расширения компилятора
  - IMMEDIATE,
  - HIDDEN
  - COMPILE
  - RECURCE
- TICK, EXECUTE
- DODOES
- системные вызовы
- управляющие слова (IF THEN ELSE UNLESS GOTO COMEFROM CASE)
- циклы
- декомпилятор
- исключения
- печать словаря
- дамп
- многопоточность, в том числе green threads (fibers)

Эта работы вдохновлена ~jonesforth~

Она описана тут: [[file:mfm.org][Minimal Forth Maсhine]]

* Forth Assembler

Эта часть работы является необязательной, чтобы весь проект
заработал. Но она важна для производительности.

В общем случае, более высокоуровневые слои будут поставлять
форт-машине код, который она должна будет исполнить.

Для этого кода существует множество преобразований, которые
можно выполнить для улучшения характеристик. Одним из них
является Just-In-Time компиляция.

Поэтому форт-ассемблер, способный производить на лету код
для целевой архитектуры может быть очень полезным.

Для каждой из целевых архитектур он будет своим, поэтому мы
должны иметь возмоность подключать и отключать словари,
которые реализуют этот функционал

* Garbage Collector

Для написания высокоуровневых языков необходимо
автоматизировать управление памятью, поэтому нам необходим
сборщик мусора.

Скорее всего он будет не в единственном экземпляре и
включать в себя платформенно-зависимые части.

Поэтому разумно сделать его подключаемым и, возможно, даже
переключаемым (стоит исследовать, есть ли сценарии, где
сборщик мусора может быть заменен прямо во время работы
системы).

* Minimal Lisp System

Теперь можно построить минимальную лисп-систему. Она будет
основой для построения языков предметной области и других
инструментов, таких как отладчики, анализаторы кода и др.

Эта работа вдохновлена MAL (https://github.com/kanaka/mal)

* Prolog-like solver (SAT) and Planner features

- Резолюция
- Унификация

* Refal features

- Суперкомпиляция
