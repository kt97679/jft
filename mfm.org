#+STARTUP: showall indent hidestars
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{gensymb}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[english,main=russian]{babel}
#+LaTeX_CLASS: beamer
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \pagecolor{black}
#+LATEX_HEADER: \color{white}


MFM - Minimal Forth Machine

* Targets

x86 (32-bits), x86_64 (64b-bits), ...

* Macroses

:PROPERTIES:
:VISIBILITY: children
:END:
** WZ - Word Size

#+NAME: m_wz
#+BEGIN_EXAMPLE asm
  .set WZ, _wz_
#+END_EXAMPLE

** NEXT

[TODO:gmm] - optimization for 32, 16, 8

#+NAME: next
#+BEGIN_SRC elisp :var arg=sub_next :results value
  (defun next-opt-64 (in)
    (replace-regexp-in-string
     "mov\s+\(\s*%rsi\s*\)\s*\,\s*%rax\s*\n\s*add\s+0x08\s*\,\s*%rsi"
     "lodsq" in t t))

  (print arg)
  (next-opt-64 (wrp arg))
#+END_SRC

#+NAME: sub_next
#+BEGIN_EXAMPLE asm
  # NEXT
      mov     (%IPR), %ACR
      add     _wz_, %IPR
      jmp     *(%ACR)
#+END_EXAMPLE

** push and pop RSP

[TODO:gmm] - params for macro

#+NAME: pushrsp
#+BEGIN_SRC elisp :var arg=sub_pushrsp :results value
  (wrp arg)
#+END_SRC

#+NAME: poprsp
#+BEGIN_SRC elisp :var arg=sub_poprsp :results value
  (wrp arg)
#+END_SRC

#+NAME: sub_pushrsp
#+BEGIN_EXAMPLE asm
  .macro PUSHRSP reg
      lea     -_wz_(%RSR), %RSR   # декремент %RSR на _wz_
      mov     \reg, (%RSR)        # push reg в стек возвратов
  .endm
#+END_EXAMPLE

#+NAME: sub_poprsp
#+BEGIN_EXAMPLE asm
  .macro POPRSP reg
      mov     (%RSR), \reg        # pop с вершины стека возвратов в reg
      lea     _wz_(%RSR), %RSR    # инкремент %RSR на _wz_
  .endm
#+END_EXAMPLE

** defcode

#+NAME: defcode
#+BEGIN_EXAMPLE asm
  .macro defcode name, namelen, flags=0, label
      .section .rodata
      .align 4
      .globl name_\label
  name_\label :
      .int    link               # link
      .set    link,name_\label
      .byte   \flags+\namelen    # flags + байт длины
      .ascii  "\name"            # имя
      .align  4                  # выравнивание на 4-х байтовую границу
      .globl  \label
  \label :
      .int    code_\label        # codeword
      .text
      //.align 4
      .globl  code_\label
  code_\label :
      # далее следует ассемблерный код
  .endm
#+END_EXAMPLE

** defvar

#+NAME: defvar
#+BEGIN_EXAMPLE asm
  .macro defvar name, namelen, flags=0, label, initial=0
      defcode \name,\namelen,\flags,\label
      push    $var_\name
      NEXT
      .data
      .align 4
      var_\name :
      .int \initial
  .endm
#+END_EXAMPLE

* Docol

#+NAME: docol
#+BEGIN_EXAMPLE asm
      .text
      .align _wz_
  DOCOL:
      PUSHRSP %IPR                # сохранить %IPR в стеке возвратов
      lea     _wz_(%ACR), %IPR    # %IPR теперь указывает на param-field
      NEXT                        # делаем NEXT
#+END_EXAMPLE

* Build-in vars

#+NAME: built_in_vars
#+BEGIN_EXAMPLE asm
  defvar "STATE",5,,STATE
  defvar "HERE",4,,HERE
  defvar "LATEST",6,,LATEST,name_SYSCALL0  # SYSCALL0 должен быть последним встроенным словом
  defvar "S0",2,,SZ
  defvar "BASE",4,,BASE,10
#+END_EXAMPLE

* Settings

#+NAME: settings
#+BEGIN_SRC elisp :results output
  (setq *_wz_*  "0x08")  ;; |   4 | 2
  (setq *!*     "q")     ;; |   l | d  - Suffix of operand
  (setq *%ACR*  "%rax")  ;; | eax | ax - Accumulator Register
  (setq *%IPR*  "%rsi")  ;; | esi | si - Insturction Pointer Register
  (setq *%RSR*  "%rbp")  ;; | ebp | bp - Return Stack Register
#+END_SRC

* Tangle

  <<settings()>>
  <<base()>>
  <<start()>>

#+NAME: mfm
#+BEGIN_SRC asm :tangle src/mfm.S :noweb yes :results output
  <<test()>>
#+END_SRC

#+NAME: base
#+BEGIN_SRC elisp :results output
  (defun rep (str replace regexp)
    (replace-regexp-in-string regexp replace str t t))

  (defun wrp (arg)
    (let ((arg arg))
      (setq arg (rep arg *_wz_* "_wz_"))
      (setq arg (rep arg *!*    "!"   ))
      (setq arg (rep arg *%ACR* "%ACR"))
      (setq arg (rep arg *%IPR* "%IPR"))
      (setq arg (rep arg *%RSR* "%RSR"))))

  (defun macroexpand (arg)
    (let ((next (org-sbe next)))
      (rep arg next "\\[NEXT\\]")
      ))
#+END_SRC

C-x RET C-\ - (set-input-method)


#+NAME: test
#+BEGIN_SRC elisp :var arg=sub_test :results output
  (defun re-asm (param)
    (block ram
      (if (string-equal "" param)
          (return-from ram `(:empty))
        (let ((result `(:ident ,(- (length param) (length (string-trim-left param))))))
          (replace-regexp-in-string
           "#\\(.*\\)" ;; comment-line
           (lambda (in)
             (setf result (append result `(:comment-line ,in)))
             (return-from ram result))
           param)
          (replace-regexp-in-string
           "\\(.*\\)\s+\\(.*\\)" ;; cmd
           (lambda (in)
             (let ((cmd (split-string (string-trim in))))
               (print cmd)
               (pcase cmd
                 (`("mov" ,from ,to)
                  (setf result (append result `(:cmd :mov :from ,from :to ,to)))))
               ;; (setf result (append result `(:cmd ,cmd)))
               (return-from ram result)))
           param)))))

  (mapcar #'(lambda (in) (princ "\n") (prin1 in))
          (mapcar #'re-asm
                  (split-string arg "\n" nil nil)))
#+END_SRC

#+NAME: sub_test
#+BEGIN_EXAMPLE asm :noweb yes
  # NEXT
    # NEXTER
      mov     (%IPR), %ACR
      mov     (%IPR), %ACR # with comment
      add     _wz_, %IPR

      jmp     *(%ACR)
      nop
#+END_EXAMPLE



#+NAME: start
#+BEGIN_SRC elisp :var arg=sub_start :results value
  ;; (print
  ;;  (replace-regexp-in-string
  ;;   "nop"
  ;;   "lodsq" in t t))
#+END_SRC


[TODO:gmm] - Количество параметров командной строки
[TODO:gmm] - Указатель на параметры командной строки

[TODO:gmm] - псевдорегистры

#+NAME: sub_start
#+BEGIN_EXAMPLE asm :noweb yes
  # START
      .text
      .globl  _start
      .type   _start, @function
  _start:
      # Сбрасываем флаг направления
      cld
      # Записываем вершину стека параметров %esp в переменную S0
      mov     %esp, (var_S0)
      # Устанавливаем стек возвратов %ebp
      mov     $return_stack_top, %ebp
      # Устанавливаем указатель HERE на начало области данных.
      mov     $data_buffer, %eax
      mov     %eax, (var_HERE)
      # Инициализируем IP
      mov     $cold_start, %esi
      # Запускаем интерпретатор
      [NEXT]

      .section .rodata
  cold_start:                 # High-level code without a codeword.
      .int QUIT
#+END_EXAMPLE
