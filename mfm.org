#+STARTUP: showall indent hidestars

MFM - Minimal Forth Machine

* Targets

x86 (32-bits), x86_64 (64b-bits), ...

* Macroses

** WZ - Word Size

#+NAME: m_wz
#+BEGIN_SRC elisp :result output
  (format ".set WZ, %s" *wz*)
#+END_SRC

** NEXT

#+NAME: next_x86_or_x86_64
#+BEGIN_EXAMPLE asm
  .macro NEXT
      lods
      jmp *(%ACR)
  .endm
#+END_EXAMPLE

** push and pop RSP

#+NAME: pushrsp_and_poprsp_x86_or_x86_64
#+BEGIN_EXAMPLE asm
  .macro PUSHRSP reg
      lea     -_wz_(%RSR), %RSR   # декремент %RSR на _wz_
      mov     \reg, (%RSR)        # push reg в стек возвратов
  .endm

  .macro POPRSP reg
      mov     (%RSR), \reg        # pop с вершины стека возвратов в reg
      lea     _wz_(%RSR), %RSR    # инкремент %RSR на _wz_
  .endm
#+END_EXAMPLE

* Docol

#+NAME: docol_x86_or_x86_64
#+BEGIN_EXAMPLE asm
      .text
      .align _wz_
  DOCOL:
      PUSHRSP %IPR                # сохранить %IPR в стеке возвратов
      lea     _wz_(%ACR), %IPR    # %IPR теперь указывает на param-field
      NEXT                        # делаем NEXT
#+END_EXAMPLE

* Tangle

#+NAME: wrp
#+BEGIN_SRC elisp :var arg="=!="
  (defun rep (place var)
    (setf arg (replace-regexp-in-string place (format "%s" var) arg t t)))

  (rep "_wz_" "0x08") ;; |   4 | 2
  (rep "!" "q");; |   l | d    - Suffix of operand
  (rep "%ACR" "%rax")  ;; | eax | ax - Accumulator Register
  (rep "%IPR" "%rsi")   ;; | esi | si - Insturction Pointer Register
  (rep "%RSR" "%rbp") ;; | ebp | bp - Return Stack Register
  arg
#+END_SRC

#+NAME: macroses
#+BEGIN_SRC asm :noweb yes
  <<m_wz()>>

  <<wrp(next_x86_or_x86_64)>>
  <<wrp(pushrsp_and_poprsp_x86_or_x86_64)>>
  <<wrp(docol_x86_or_x86_64)>>
#+END_SRC


#+NAME: all
#+BEGIN_SRC asm :tangle src/all.S :noweb tangle :exports code :padline no :comments none
  <<macroses>>

      .globl  _start
      .type   _start, @function
  _start:
#+END_SRC
