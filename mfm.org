#+STARTUP: showall indent hidestars

MFM - Minimal Forth Machine

* Intro

Цель этого шага - написание минимальной форт-машины, полностью
независимым от платформы и внешнего компилятора образом.

На её базе будет написан более высокоуровневый язык, способный
скомпилировать эту форт-машину без внешнего компилятора (bootstaping).

Пока такого языка еще нет я буду использовать emacs-lisp, чтобы
сформировать некоторый "промежуточный ассемблер", который может быть
скомпилирован под любую архитектуру, включая, но не ограничиваясь:
- 8-разрядный AVR
- 16-разрядный x86
- 32-разрядный x86
- 32-разрядный ARM
- 64-разрядный x86_64
- WebAssembly VM
- ...

Текущее состояние - Proof-of-Concept, требуется показать способность
решения компилировать какой-то минимальный код, не зависящий от
разрядности используемой архитектуры.

* Minimal Machine Architecture

Для функциионирования форт-машины требуется стек и минимальный набор
абстрактных регистров:
- %ACR - Accumilator Register
- %IPR - Instruction Pointer Register
- %RSR - Return Stack Register
- %DSR - Data Stack Register
- ...

Я буду использовать эти регистры в своем коде "абстрактного ассемблера",
а при компиляции они будут сопоставляться с конкретными выбранными
регистрами целевого ассемблера, при этом целевой ассемблер я тоже напишу
сам, чтобы иметь полную свободу применения любых оптимизаций

* Minimal incoming code

Минимальный пример кода должен быть похож на код для GNU Assembler, на
который я опираюсь и иметь:
- комментарии после команды до конца строки
- коментарии, занимающие всю строку
- некоторую поддержку отступов для удобства
- пустые строки
- двухоперандные команды перемещения значений (mov)
  - из регистра в регистр
  - из памяти в регистр
  - из регистра в память
- команды передачи управления (jmp)
  - прямой регистровый переход - jmp (reg)
- метки

Такого минимального синтаксиса будет достаточно для написания
форт-машины, которая станет следующим уровнем языка. Также такой подход
позволяет восстановить исходный код после разбора (для удобства отладки)

** Minimal Code Snippet

Эти несколько строчек кода включают все вышеперечисленные варианты. Они
поступают на вход процедуре разбора "абстрактного ассемблера"

#+NAME: min_aasm
#+BEGIN_EXAMPLE asm

  # FIRST COMMENT
    # COMMENT WITH INDENTATION
      mov     %IPR, %ACR     # mov reg to reg
      mov     %IPR, %ACR
      mov     (%IPR), %ACR   # mov mem to reg
      mov     (%IPR), %ACR
      mov     %IPR, (%ACR)   # mov reg to mem
      mov     %IPR, (%ACR)
      jmp     %IRP           # jmp reg
      jmp     %IRP
      jmp     _label         # jmp label
      jmp     _label
  _label_with_comment:       # this is label
  _label:
#+END_EXAMPLE

* Parsing of Abstract Assembler Code

Этот кусок кода разбирает минимальный сниппет кода на "абстрактном
ассемблере", чтобы получить из него список S-выражений

#+NAME: p_aasm
#+BEGIN_SRC elisp :var arg=min_aasm :results output
  (defun p-aasm (param)
    (block ram
      (if (or (string-equal "" param)
              (string-equal "" (string-trim-left param)))
          (return-from ram `(:empty))
        (let* ((out   `(:ident ,(- (length param) (length (string-trim-left param)))))
               (param     (string-trim-left param))
               (reg-size  4)
               (reg     "\\(%[a-z]\\{3\\}\\)"))
          (replace-regexp-in-string
           "^#\\(.*\\)" ;; comment-line
           (lambda (in)
             (setf out (append out `(:comment-line ,in)))
             (return-from ram out))
           param)
          (save-match-data ;; mov reg to reg
            (and (string-match (concat "^mov\s*" reg "\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_reg_to_reg :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; mov mem to reg
            (and (string-match (concat "^mov\s*(" reg ")\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_mem_to_reg :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; mov reg to mem
            (and (string-match (concat "^mov\s*" reg "\s*,\s*(" reg ")\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_reg_to_mem :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; jmp reg
            (and (string-match (concat "^jmp\s*" reg "\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :jmp_reg
                                      :to ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          (save-match-data ;; jmp label
            (and (string-match
                  (concat "^jmp\s*" "\\([_a-zA-z]+\\)" "\s?\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :jmp_label
                                      :to ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          (save-match-data ;; label
            (and (string-match
                  (concat "^\\([_a-zA-z]+\\):" "\s?\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :label
                                      :name ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          ))))

  (mapcar #'(lambda (in) (princ "\n") (prin1 in))
          (mapcar #'p-aasm
                  (split-string arg "\n" nil nil)))
#+END_SRC

#+results: p_aasm
#+begin_example

(:empty)
(:ident 0 :comment-line "# FIRST COMMENT")
(:ident 2 :comment-line "# COMMENT WITH INDENTATION")
(:ident 4 :cmd :mov_reg_to_reg :from "%IPR" :to "%ACR" :rest "     # mov reg to reg")
(:ident 4 :cmd :mov_reg_to_reg :from "%IPR" :to "%ACR" :rest "")
(:ident 4 :cmd :mov_mem_to_reg :from "%IPR" :to "%ACR" :rest "   # mov mem to reg")
(:ident 4 :cmd :mov_mem_to_reg :from "%IPR" :to "%ACR" :rest "")
(:ident 4 :cmd :mov_reg_to_mem :from "%IPR" :to "%ACR" :rest "   # mov reg to mem")
(:ident 4 :cmd :mov_reg_to_mem :from "%IPR" :to "%ACR" :rest "")
(:ident 4 :cmd :jmp_reg :to "%IRP" :rest "           # jmp reg")
(:ident 4 :cmd :jmp_reg :to "%IRP" :rest "")
(:ident 4 :cmd :jmp_label :to "_label" :rest "        # jmp label")
(:ident 4 :cmd :jmp_label :to "_label" :rest "")
(:ident 0 :cmd :label :name "_label_with_comment" :rest "      # this is label")
(:ident 0 :cmd :label :name "_label" :rest "")
(:empty)
#+end_example

* Macroses

:PROPERTIES:
:VISIBILITY: children
:END:
** WZ - Word Size

#+NAME: m_wz
#+BEGIN_EXAMPLE asm
  .set WZ, _wz_
#+END_EXAMPLE

** NEXT

[TODO:gmm] - optimization for 32, 16, 8

#+NAME: next
#+BEGIN_SRC elisp :var arg=sub_next :results value
  (defun next-opt-64 (in)
    (replace-regexp-in-string
     "mov\s+\(\s*%rsi\s*\)\s*\,\s*%rax\s*\n\s*add\s+0x08\s*\,\s*%rsi"
     "lodsq" in t t))

  (print arg)
  (next-opt-64 (wrp arg))
#+END_SRC

#+NAME: sub_next
#+BEGIN_EXAMPLE asm
  # NEXT
      mov     (%IPR), %ACR
      add     _wz_, %IPR
      jmp     *(%ACR)
#+END_EXAMPLE

** push and pop RSP

[TODO:gmm] - params for macro

#+NAME: pushrsp
#+BEGIN_SRC elisp :var arg=sub_pushrsp :results value
  (wrp arg)
#+END_SRC

#+NAME: poprsp
#+BEGIN_SRC elisp :var arg=sub_poprsp :results value
  (wrp arg)
#+END_SRC

#+NAME: sub_pushrsp
#+BEGIN_EXAMPLE asm
  .macro PUSHRSP reg
      lea     -_wz_(%RSR), %RSR   # декремент %RSR на _wz_
      mov     \reg, (%RSR)        # push reg в стек возвратов
  .endm
#+END_EXAMPLE

#+NAME: sub_poprsp
#+BEGIN_EXAMPLE asm
  .macro POPRSP reg
      mov     (%RSR), \reg        # pop с вершины стека возвратов в reg
      lea     _wz_(%RSR), %RSR    # инкремент %RSR на _wz_
  .endm
#+END_EXAMPLE

** defcode

#+NAME: defcode
#+BEGIN_EXAMPLE asm
  .macro defcode name, namelen, flags=0, label
      .section .rodata
      .align 4
      .globl name_\label
  name_\label :
      .int    link               # link
      .set    link,name_\label
      .byte   \flags+\namelen    # flags + байт длины
      .ascii  "\name"            # имя
      .align  4                  # выравнивание на 4-х байтовую границу
      .globl  \label
  \label :
      .int    code_\label        # codeword
      .text
      //.align 4
      .globl  code_\label
  code_\label :
      # далее следует ассемблерный код
  .endm
#+END_EXAMPLE

** defvar

#+NAME: defvar
#+BEGIN_EXAMPLE asm
  .macro defvar name, namelen, flags=0, label, initial=0
      defcode \name,\namelen,\flags,\label
      push    $var_\name
      NEXT
      .data
      .align 4
      var_\name :
      .int \initial
  .endm
#+END_EXAMPLE

* Docol

#+NAME: docol
#+BEGIN_EXAMPLE asm
      .text
      .align _wz_
  DOCOL:
      PUSHRSP %IPR                # сохранить %IPR в стеке возвратов
      lea     _wz_(%ACR), %IPR    # %IPR теперь указывает на param-field
      NEXT                        # делаем NEXT
#+END_EXAMPLE

* Build-in vars

#+NAME: built_in_vars
#+BEGIN_EXAMPLE asm
  defvar "STATE",5,,STATE
  defvar "HERE",4,,HERE
  defvar "LATEST",6,,LATEST,name_SYSCALL0  # SYSCALL0 должен быть последним встроенным словом
  defvar "S0",2,,SZ
  defvar "BASE",4,,BASE,10
#+END_EXAMPLE

* Settings

#+NAME: settings
#+BEGIN_SRC elisp :results output
  (setq *_wz_*  "0x08")  ;; |   4 | 2
  (setq *!*     "q")     ;; |   l | d  - Suffix of operand
  (setq *%ACR*  "%rax")  ;; | eax | ax - Accumulator Register
  (setq *%IPR*  "%rsi")  ;; | esi | si - Instruction Pointer Register
  (setq *%RSR*  "%rbp")  ;; | ebp | bp - Return Stack Register
#+END_SRC

* Tangle

  <<settings()>>
  <<base()>>
  <<start()>>

#+NAME: mfm
#+BEGIN_SRC asm :tangle src/mfm.S :noweb yes :results output
  <<test()>>
#+END_SRC

#+NAME: base
#+BEGIN_SRC elisp :results output
  (defun rep (str replace regexp)
    (replace-regexp-in-string regexp replace str t t))

  (defun wrp (arg)
    (let ((arg arg))
      (setq arg (rep arg *_wz_* "_wz_"))
      (setq arg (rep arg *!*    "!"   ))
      (setq arg (rep arg *%ACR* "%ACR"))
      (setq arg (rep arg *%IPR* "%IPR"))
      (setq arg (rep arg *%RSR* "%RSR"))))

  (defun macroexpand (arg)
    (let ((next (org-sbe next)))
      (rep arg next "\\[NEXT\\]")
      ))
#+END_SRC

C-x RET C-\ - (set-input-method)


#+NAME: test
#+BEGIN_SRC elisp :var arg=sub_test :results output
  (defun re-asm (param)
    (block ram
      (if (string-equal "" param)
          (return-from ram `(:empty))
        (let ((result `(:ident ,(- (length param) (length (string-trim-left param))))))
          (replace-regexp-in-string
           "#\\(.*\\)" ;; comment-line
           (lambda (in)
             (setf result (append result `(:comment-line ,in)))
             (return-from ram result))
           param)
          (replace-regexp-in-string
           "\\(.*\\)\s+\\(.*\\)" ;; cmd
           (lambda (in)
             (let ((cmd (split-string (string-trim in))))
               (print cmd)
               (pcase cmd
                 (`("mov" ,from ,to)
                  (setf result (append result `(:cmd :mov :from ,from :to ,to)))))
               ;; (setf result (append result `(:cmd ,cmd)))
               (return-from ram result)))
           param)))))

  (mapcar #'(lambda (in) (princ "\n") (prin1 in))
          (mapcar #'re-asm
                  (split-string arg "\n" nil nil)))
#+END_SRC

#+NAME: sub_test
#+BEGIN_EXAMPLE asm :noweb yes
  # NEXT
    # NEXTER
      mov     (%IPR), %ACR
      mov     (%IPR), %ACR # with comment
      add     _wz_, %IPR

      jmp     *(%ACR)
      nop
#+END_EXAMPLE



#+NAME: start
#+BEGIN_SRC elisp :var arg=sub_start :results value
  ;; (print
  ;;  (replace-regexp-in-string
  ;;   "nop"
  ;;   "lodsq" in t t))
#+END_SRC


[TODO:gmm] - Количество параметров командной строки
[TODO:gmm] - Указатель на параметры командной строки

[TODO:gmm] - псевдорегистры

#+NAME: sub_start
#+BEGIN_EXAMPLE asm :noweb yes
  # START
      .text
      .globl  _start
      .type   _start, @function
  _start:
      # Сбрасываем флаг направления
      cld
      # Записываем вершину стека параметров %esp в переменную S0
      mov     %esp, (var_S0)
      # Устанавливаем стек возвратов %ebp
      mov     $return_stack_top, %ebp
      # Устанавливаем указатель HERE на начало области данных.
      mov     $data_buffer, %eax
      mov     %eax, (var_HERE)
      # Инициализируем IP
      mov     $cold_start, %esi
      # Запускаем интерпретатор
      [NEXT]

      .section .rodata
  cold_start:                 # High-level code without a codeword.
      .int QUIT
#+END_EXAMPLE
