# -*- mode: org; fill-column: 60; -*-
#+STARTUP: showall indent hidestars

AASM - Abstract Assembler

* Intro

Я буду использовать emacs-lisp, чтобы сформировать некоторый
"промежуточный ассемблер", который может быть скомпилирован под любую
архитектуру, включая, но не ограничиваясь:
- 8-разрядный AVR
- 16-разрядный x86
- 32-разрядный x86
- 32-разрядный ARM
- 64-разрядный x86_64
- WebAssembly VM
- ...

Текущее состояние - Proof-of-Concept, требуется показать способность
решения компилировать какой-то минимальный код, не зависящий от
разрядности используемой архитектуры.

* Motivation

Стараясь следовать идее минимализма, но не в ущерб определенности, я
предпочел бы иметь минимальный набор самых низкоуровневых машинных
команд, чтобы на нем построить все остальное. Такой минимальный набор
нужен для каждой целевой архитектуры, и он должен быть очень гибким,
чтобы работать на процессорах с разной длиной машинного слова и разным
набором команд.

Однако, не хотелось бы полностью писать этот архитектурно-зависимый слой,
потому что у всех архитектур есть нечто общее: несколько регистров и
обращения к памяти. Регистры могут иметь разную рязрядность (8 бит - 64
бита), на обращения к памяти могут накладывать ограничения (ARM), но
общего достаточно много.

Также хотелось бы, иметь полный контроль за тем, как будут
ассемблироваться команды - по этой причине не стоит делать этот слой с
использованием любого строннего компилятора, например компилятора си
(gcc) или ассемблера (nasm). У них могут быть различия в работе от версии
к версии или от платформы к платформе и поэтому невозможно с уверенностью
контролировать процесс ассемблирования.

Это особенно важно, если когда-нибудь захочется применять
машинно-специфичные оптимизации, такие как распределение регистров, или
JIT-компиляцию.

Исходя из этого оптимальное решение - написать миниатюрный ассемблер
абстрактной машины, регистры и команды которой платформо-зависимы.

* Minimal machine architecture

Для функциионирования форт-машины требуется стек и минимальный набор
абстрактных регистров, которые позже будут мапиться на реальные:
- %ACR - Accumilator Register
- %IPR - Instruction Pointer Register
- %RSR - Return Stack Register
- %DSR - Data Stack Register
- ...

Я буду использовать эти регистры в своем коде "абстрактного ассемблера",
а при компиляции они будут сопоставляться с конкретными выбранными
регистрами целевого ассемблера, при этом целевой ассемблер я тоже напишу
сам, чтобы иметь полную свободу применения любых оптимизаций

* Minimal incoming code

минимальный пример кода должен быть похож на код для gnu assembler, на
который я опираюсь и иметь:
- комментарии после команды до конца строки
- коментарии, занимающие всю строку
- некоторую поддержку отступов для удобства
- пустые строки
- двухоперандные команды перемещения значений (mov)
  - из регистра в регистр
  - из памяти в регистр
  - из регистра в память
- команды передачи управления (jmp)
  - прямой регистровый переход - jmp (reg)
- метки

такого минимального синтаксиса будет достаточно для написания
форт-машины, которая станет следующим уровнем языка. также такой подход
позволяет восстановить исходный код после разбора (для удобства отладки)

* Minimal code snippet

эти несколько строчек кода включают все вышеперечисленные варианты. они
поступают на вход процедуре разбора "абстрактного ассемблера"

#+name: min_aasm
#+begin_example asm

  # first COMMENT
    # COMMENT with indentation
      mov     %IPR, %ACR     # mov reg to reg
      mov     %IPR, %ACR
      mov     (%IPR), %ACR   # mov mem to reg
      mov     (%IPR), %ACR
      mov     %IPR, (%ACR)   # mov reg to mem
      mov     %IPR, (%ACR)
      jmp     %IRP           # jmp reg
      jmp     %IRP
      jmp     _label         # jmp label
      jmp     _label
  _label_with_comment:       # this is label
  _label:
#+END_EXAMPLE

* Parsing of Abstract Assembler Code

Этот кусок кода разбирает минимальный сниппет кода на "абстрактном
ассемблере", чтобы получить из него список S-выражений

#+NAME: p_aasm
#+BEGIN_SRC elisp :var arg=min_aasm :results value list pp
  (defun p-aasm (param)
    (block ram
      (if (or (string-equal "" param)
              (string-equal "" (string-trim-left param)))
          (return-from ram `(:empty))
        (let* ((out   `(:ident ,(- (length param) (length (string-trim-left param)))))
               (param     (string-trim-left param))
               (reg-size  4)
               (reg     "\\(%[a-zA-Z]\\{3\\}\\)")
               (case-fold-search nil))
          (replace-regexp-in-string
           "^#\\(.*\\)" ;; comment-line
           (lambda (in)
             (setf out (append out `(:comment-line ,in)))
             (return-from ram out))
           param)
          (save-match-data ;; mov reg to reg
            (and (string-match (concat "^mov\s*" reg "\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_reg_to_reg :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; mov mem to reg
            (and (string-match (concat "^mov\s*(" reg ")\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_mem_to_reg :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; mov reg to mem
            (and (string-match (concat "^mov\s*" reg "\s*,\s*(" reg ")\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_reg_to_mem :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; jmp reg
            (and (string-match (concat "^jmp\s*" reg "\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :jmp_reg
                                      :to ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          (save-match-data ;; jmp label
            (and (string-match
                  (concat "^jmp\s*" "\\([_a-zA-z]+\\)" "\s?\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :jmp_label
                                      :to ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          (save-match-data ;; label
            (and (string-match
                  (concat "^\\([_a-zA-Z]+\\):" "\s?\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :label
                                      :name ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          ))))

  (mapcar #'(lambda (in) (princ "\n") (prin1 in))
          (mapcar #'p-aasm
                  (split-string arg "\n" nil nil)))
#+END_SRC

#+results: p_aasm
#+begin_example
- ((:empty)
- (:ident 0 :comment-line "# first COMMENT")
- (:ident 2 :comment-line "# COMMENT with indentation")
- (:ident 4 :cmd :mov_reg_to_reg :from "%IPR" :to "%ACR" :rest "     # mov reg to reg")
- (:ident 4 :cmd :mov_reg_to_reg :from "%IPR" :to "%ACR" :rest "")
- (:ident 4 :cmd :mov_mem_to_reg :from "%IPR" :to "%ACR" :rest "   # mov mem to reg")
- (:ident 4 :cmd :mov_mem_to_reg :from "%IPR" :to "%ACR" :rest "")
- (:ident 4 :cmd :mov_reg_to_mem :from "%IPR" :to "%ACR" :rest "   # mov reg to mem")
- (:ident 4 :cmd :mov_reg_to_mem :from "%IPR" :to "%ACR" :rest "")
- (:ident 4 :cmd :jmp_reg :to "%IRP" :rest "           # jmp reg")
- (:ident 4 :cmd :jmp_reg :to "%IRP" :rest "")
- (:ident 4 :cmd :jmp_label :to "_label" :rest "        # jmp label")
- (:ident 4 :cmd :jmp_label :to "_label" :rest "")
- (:ident 0 :cmd :label :name "_label_with_comment" :rest "      # this is label")
- (:ident 0 :cmd :label :name "_label" :rest "")
- (:empty))
#+end_example

* GNU Assembler Producer

Нужен для проверочных целей

#+NAME: gas_producer
#+BEGIN_SRC elisp :var arg=p_aasm :results output
  (defun gas-emit (in)
      (pcase in
        (`(:empty)  "")
        (`(:ident ,idnt :comment-line ,cmnt)
         (princ (format "%s%s\n" (make-string idnt ? ) cmnt)))
        (`(:ident ,idnt :cmd :mov_reg_to_reg :from ,from :to ,to :rest ,rest)
         (princ (format "%smov     %s, %s%s\n" (make-string idnt ? ) from to rest)))
        (`(:ident ,idnt :cmd :mov_mem_to_reg :from ,from :to ,to :rest ,rest)
         (princ (format "%smov     (%s), %s%s\n" (make-string idnt ? ) from to rest)))
        (`(:ident ,idnt :cmd :mov_reg_to_mem :from ,from :to ,to :rest ,rest)
         (princ (format "%smov     %s, (%s)%s\n" (make-string idnt ? ) from to rest)))
        (`(:ident ,idnt :cmd :jmp_reg :to ,to :rest ,rest)
         (princ (format "%sjmp     %s%s\n" (make-string idnt ? ) to rest)))
        (`(:ident ,idnt :cmd :jmp_label :to ,to :rest ,rest)
         (princ (format "%sjmp     %s%s\n" (make-string idnt ? ) to rest)))
        (`(:ident ,idnt :cmd :label :name ,name :rest ,rest)
         (princ (format "%s%s%s\n" (make-string idnt ? ) name rest)))
        (_  (print in))))

  (mapcar #'gas-emit
          (car (read-from-string arg)))
#+END_SRC

#+results: gas_producer
#+begin_example
# first COMMENT
  # COMMENT with indentation
    mov     %IPR, %ACR     # mov reg to reg
    mov     %IPR, %ACR
    mov     (%IPR), %ACR   # mov mem to reg
    mov     (%IPR), %ACR
    mov     %IPR, (%ACR)   # mov reg to mem
    mov     %IPR, (%ACR)
    jmp     %IRP           # jmp reg
    jmp     %IRP
    jmp     _label        # jmp label
    jmp     _label
_label_with_comment      # this is label
_label
#+end_example

* START Opcode Producer

Каждая инструкция (почти) любого процессора имеет некоторый ~требуемый
эффект~, ради которого мы ее применяем. Обычно эффект выражается в
изменении регистров, памяти и флагов процессора.

Часто этот же требуемый эффект может быть достигнут комбинацией других
инструкций. Это дает нам возможность строить эквивалентные программы для
любых целей (оптимизация по скорости и размеру кода, обфускация, и.т.п)

Также у инструкции может быть ~побочный эффект~ (что еще изменяет эта
инструкция, кроме требуемого эффекта). На такие ~побочные эффекты~ можно
наложить ограничения, которые сработают при поиске и выборе нужных
инструкций, когда мы строим программу по эффектам.

Пользуясь данными об эффектах мы можем запустить солвер, чтобы построить
необходимую программу.

Для задачи построения виртуальной машины это не требуется, но если сейчас
заложить несколько вариантов достижения ~требуемых эффектов~, это может
пригодиться для генерализации подхода.

[TODO:gmm] - Написать солвер

** x86_64 Producer


Обычная инструкция на x86_64 имеет переменную длину (до 15 байт) и может
состоять из нескольких компонентов, порядок которых определен:
- Legacy prefixes (1-4 bytes, optional)
- Opcode with prefixes (1-4 bytes, required)
- ModR/M (1 byte, может отсутствовать, если опкод не имеет явных
  операндов)
- SIB (1 byte, для адресации операндов в памяти - может отсутствовать)
- Displacement (1, 2, 4 or 8 bytes, if required)
- Immediate (1, 2, 4 or 8 bytes, if required)

--skiped:https://www.youtube.com/watch?v=CUAXCeRjw3c:--

- Prefixes (REX, VEX : https://habr.com/ru/company/intel/blog/200598/)
  Использование REX позволяет расширить набор регистров
  r8-r15

- Links:
  - http://www.c-jump.com/CIS77/CPU/x86/X77_0060_mod_reg_r_m_byte.htm
  - https://stackoverflow.com/questions/15511482/x64-instruction-encoding-and-the-modrm-byte
  - https://sandpile.org/x86/opc_rm.htm

ModRM:
- mod[7:6] - 4 метода адресации
  - 00b Register indirect addressing mode or SIB with no
    displacement (when R/M=100b) or Displacement only
    addressing mode (when R/M=101b).
  - 01b One-byte signed displacement follows addressing mode
    byte(s).
  - 10b Four-byte signed displacement follows addressing mode byte(s).
  - 11b Register addressing mode.
- reg[.R, 5:3] - register-based operand or extend operation encoding
- r/m[.B, 2:0] – register or memory operand when combined with mod field.
- Addressing mode can include a following SIB byte {mod=00b,r/m=101b}

#+NAME: tbl_x86_reg_bits
| al ax eax          | 000 | nil |
| cl cx ecx          | 001 | nil |
| dl dx edx          | 010 | nil |
| bl bx ebx          | 011 | nil |
| ah sp esp          | 100 | nil |
| ch bp ebp          | 101 | nil |
| dh si esi          | 110 | nil |
| bh di edi          | 111 | nil |
| rax                | 000 |   1 |
| rcx                | 001 |   1 |
| rdx                | 010 |   1 |
| rbx                | 011 |   1 |
| rsp                | 100 |   1 |
| rbp                | 101 |   1 |
| rsi                | 110 |   1 |
| rdi                | 111 |   1 |
| bpl                | 101 |   1 |
| sil                | 110 |   1 |
| dil                | 111 |   1 |
| r8b r8w r8d r8     | 000 | nil |
| r9b r9w r9d r9     | 001 |   1 |
| r10b r10w r10d r10 | 010 |   1 |
| r11b r11w r11d r11 | 011 |   1 |
| r12b r12w r12d r12 | 100 |   1 |
| r13b r13w r13d r13 | 101 |   1 |
| r14b r14w r14d r14 | 110 |   1 |
| r15b r15w r15d r15 | 111 |   1 |

#+NAME: gen_x86_reg_bits
#+BEGIN_SRC emacs-lisp :var rt=tbl_x86_reg_bits
  (let ((res))
    (mapcar
     (lambda (row)
       (let ((regs
              (mapcar (lambda (elt) (intern (format ":%%%s" elt)))
                      (split-string (car row))))
             (bits (cadr row))
             (wide (caddr row)))
         (push (format "    (when (one-of-them reg %s)"
                       (mapconcat '(lambda (x) (format "%s" x))
                                  regs " "))
               res)
         (push (format "      %s (list :reg #b%s :rex-w %s)))"
                       "(return-from get-x86-blk" bits wide)
               res)))
     rt)
    (push "   (error \"unknown-register\")" res)
    (print (concat (format "(defun get-x86-reg-bits (reg) \n%s\n%s)"
                           "  (block get-x86-blk"
                           (mapconcat '(lambda (x) (format "%s" x))
                                      (reverse res) "\n"))
                   ")")))
#+END_SRC


Для того чтобы переводить регистры в соответствующии им биты, нужны
следующие процедуры:

#+NAME: get_x86_reg
#+BEGIN_SRC elisp :noweb tangle
  (defmacro one-of-them (var &rest vals)
    (let ((acc))
      (dolist (elt vals)
        (push `(equal ,var ,elt) acc))
      (setq acc (reverse acc))
      (push 'or acc)
      acc))

  ;; (macroexpand '(one-of-them reg :%al :%ax :%eax :%rax))

  (defun int-to-binary-string (i)
    "convert an integer into it's binary representation in string format"
    (let ((res ""))
      (while (not (= i 0))
        (setq res (concat (if (= 1 (logand i 1)) "1" "0") res))
        (setq i (lsh i -1)))
      (if (string= res "")
          (setq res "0"))
      res))

  ;; (int-to-binary-string 6)
#+END_SRC

А для сборки инструкций в конкретные байты - вот такая:

#+NAME: cmd_plist_to_bytes
#+BEGIN_SRC elisp
  (defun cmd-plist-to-bytes (in)
    (let ((acc)
          (rex-plist (getf in :rex))
          (rex #x40))
      ;; rex if needed
      (if (not (null rex-plist))
          (when (getf rex-plist :w)
            (setf rex (logior rex #x8))
            (setf acc (append acc (list rex)))))
      ;; opcode
      (setf acc (append acc (list (getf in :op))))
      ;; modrm
      (let ((modrm 0))
        (setf modrm (ash (getf in :mod) 6))
        (setf modrm (logior modrm (ash (getf in :reg) 3)))
        (setf modrm (logior modrm (getf in :mem)))
        (setf acc (append acc (list modrm))))
      acc))

  ;; (mapcar #'(lambda (in)
  ;;             (format "%X" in))
  ;;         (cmd-plist-to-bytes
  ;;          (cadr (get-cmd-plist-x86--mov-reg-to-reg :%esi :%edi))))
#+END_SRC

Также нам понадобится все это собрать

#+NAME: abstract_assembler_cmds
#+BEGIN_SRC elisp :noweb :tangle src/aasm.el :noweb tangle :exports code
  <<get_x86_reg>>
  <<gen_x86_reg_bits(tbl_x86_reg_bits)>>
  <<mov_reg_to_reg_x86_64>>
  <<push_and_pop_reg_x86_64>>
#+END_SRC

*** DONE mov_reg_to_reg_x86_64

Prefix
- RAX - если нужен
- 0x66 - [TODO:gmm] префикс изменения размера операнда
Opcode:
- 89/r - MOV reg/mem64, reg64 - Move the contents of a 64-bit register to
  a 64-bit destination register or memory operand
- 8B/r - MOV reg64, reg/mem64 - Move the contents of a 64-bit register or
  memory operand to a 64-bit destination register.

ModR/M - [mod:7:6][reg:5:3][r/m:2:0]
mod = 11b - register-direct-addressing mode
reg: register
mem: register

#+NAME: mov_reg_to_reg_x86_64
#+BEGIN_SRC elisp
  (defun get-cmd-plist-x86--mov-reg-to-reg (from to)
    (let ((reg1  (get-x86-reg-bits from))
          (reg2  (get-x86-reg-bits to))
          (rex   nil))
      (cond ((and (getf reg1 :rex-w)
                  (getf reg2 :rex-w))
             (progn
               (setf (getf rex :w) t)
               (setf reg1 (getf reg1 :reg))
               (setf reg2 (getf reg2 :reg))))
            ((and (null (getf reg1 :rex-w))
                  (null (getf reg2 :rex-w)))
             (progn (setf reg1 (getf reg1 :reg))
                    (setf reg2 (getf reg2 :reg))))
            (t (let ((errstr (format "rex-w mismatch %s %s" from to)))
                 (print errstr)
                 (error "ERR: rex-w mismatch"))))
      (values
       `(:rex ,rex :op #x89 :mod #b11 :reg ,reg1 :mem ,reg2)
       `(:rex ,rex :op #x8B :mod #b11 :reg ,reg2 :mem ,reg1))))

  ;; (get-cmd-plist-x86--mov-reg-to-reg :%esi :%edi)
  ;; (get-cmd-plist-x86--mov-reg-to-reg :%rsi :%rdi)

#+END_SRC

*** DONE push_and_pop_reg_x86_64

For the first 8 registers push/pop reg is a 1 byte command. Byte value is obtained
from the expression op + reg where op is 0x50 for push and
0x58 for pop. Reg value can be found in the table above.

#+NAME: push_and_pop_reg_x86_64
#+BEGIN_SRC elisp
  (defun cmd-short-plist-to-bytes (in)
    (list (logior (ash (getf in :op) 3)
                  (getf in :reg))))

  (defun get-cmd-plist-x86--push-reg (source)
    (let ((reg (getf (get-x86-reg-bits source) :reg)))
      (values `(:op #x0A :reg ,reg))))

  ;; (get-cmd-plist-x86--push-reg :%esi)

  (defun get-cmd-plist-x86--pop-reg (target)
    (let ((reg (getf (get-x86-reg-bits target) :reg)))
      (values `(:op #x0B :reg ,reg))))

  ;; (get-cmd-plist-x86--pop-reg :%esi)

  ;; (mapcar #'(lambda (in)
  ;;             (format "%X" in))
  ;;         (cmd-short-plist-to-bytes
  ;;          (car (get-cmd-plist-x86--pop-reg :%esi))))
#+END_SRC

*** TODO jmp_reg_x86_64
#+NAME:
#+BEGIN_SRC
#+END_SRC

*** TODO je_x86_64

* TODO Elf maker
* TODO Disassembler
