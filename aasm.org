#+STARTUP: showall indent hidestars

AASM - Abstract Assembler

* Intro

Я буду использовать emacs-lisp, чтобы сформировать некоторый
"промежуточный ассемблер", который может быть скомпилирован под любую
архитектуру, включая, но не ограничиваясь:
- 8-разрядный AVR
- 16-разрядный x86
- 32-разрядный x86
- 32-разрядный ARM
- 64-разрядный x86_64
- WebAssembly VM
- ...

Текущее состояние - Proof-of-Concept, требуется показать способность
решения компилировать какой-то минимальный код, не зависящий от
разрядности используемой архитектуры.

* Motivation

Стараясь следовать идее минимализма, но не в ущерб определенности, я
предпочел бы иметь минимальный набор самых низкоуровневых машинных
команд, чтобы на нем построить все остальное. Такой минимальный набор
нужен для каждой целевой архитектуры, и он должен быть очень гибким,
чтобы работать на процессорах с разной длиной машинного слова и разным
набором команд.

Однако, не хотелось бы полностью писать этот архитектурно-зависимый слой,
потому что у всех архитектур есть нечто общее: несколько регистров и
обращения к памяти. Регистры могут иметь разную рязрядность (8 бит - 64
бита), на обращения к памяти могут накладывать ограничения (ARM), но
общего достаточно много.

Также хотелось бы, иметь полный контроль за тем, как будут
ассемблироваться команды - по этой причине не стоит делать этот слой с
использованием любого строннего компилятора, например компилятора си
(gcc) или ассемблера (nasm). У них могут быть различия в работе от версии
к версии или от платформы к платформе и поэтому невозможно с уверенностью
контролировать процесс ассемблирования.

Это особенно важно, если когда-нибудь захочется применять
машинно-специфичные оптимизации, такие как распределение регистров, или
JIT-компиляцию.

Исходя из этого оптимальное решение - написать миниатюрный ассемблер
абстрактной машины, регистры и команды которой платформо-зависимы.

* Minimal machine architecture

Для функциионирования форт-машины требуется стек и минимальный набор
абстрактных регистров, которые позже будут мапиться на реальные:
- %ACR - Accumilator Register
- %IPR - Instruction Pointer Register
- %RSR - Return Stack Register
- %DSR - Data Stack Register
- ...

Я буду использовать эти регистры в своем коде "абстрактного ассемблера",
а при компиляции они будут сопоставляться с конкретными выбранными
регистрами целевого ассемблера, при этом целевой ассемблер я тоже напишу
сам, чтобы иметь полную свободу применения любых оптимизаций

* Minimal incoming code

минимальный пример кода должен быть похож на код для gnu assembler, на
который я опираюсь и иметь:
- комментарии после команды до конца строки
- коментарии, занимающие всю строку
- некоторую поддержку отступов для удобства
- пустые строки
- двухоперандные команды перемещения значений (mov)
  - из регистра в регистр
  - из памяти в регистр
  - из регистра в память
- команды передачи управления (jmp)
  - прямой регистровый переход - jmp (reg)
- метки

такого минимального синтаксиса будет достаточно для написания
форт-машины, которая станет следующим уровнем языка. также такой подход
позволяет восстановить исходный код после разбора (для удобства отладки)

* Minimal code snippet

эти несколько строчек кода включают все вышеперечисленные варианты. они
поступают на вход процедуре разбора "абстрактного ассемблера"

#+name: min_aasm
#+begin_example asm

  # first COMMENT
    # COMMENT with indentation
      mov     %IPR, %ACR     # mov reg to reg
      mov     %IPR, %ACR
      mov     (%IPR), %ACR   # mov mem to reg
      mov     (%IPR), %ACR
      mov     %IPR, (%ACR)   # mov reg to mem
      mov     %IPR, (%ACR)
      jmp     %IRP           # jmp reg
      jmp     %IRP
      jmp     _label         # jmp label
      jmp     _label
  _label_with_comment:       # this is label
  _label:
#+END_EXAMPLE

* Parsing of Abstract Assembler Code

Этот кусок кода разбирает минимальный сниппет кода на "абстрактном
ассемблере", чтобы получить из него список S-выражений

#+NAME: p_aasm
#+BEGIN_SRC elisp :var arg=min_aasm :results value list pp
  (defun p-aasm (param)
    (block ram
      (if (or (string-equal "" param)
              (string-equal "" (string-trim-left param)))
          (return-from ram `(:empty))
        (let* ((out   `(:ident ,(- (length param) (length (string-trim-left param)))))
               (param     (string-trim-left param))
               (reg-size  4)
               (reg     "\\(%[a-zA-Z]\\{3\\}\\)")
               (case-fold-search nil))
          (replace-regexp-in-string
           "^#\\(.*\\)" ;; comment-line
           (lambda (in)
             (setf out (append out `(:comment-line ,in)))
             (return-from ram out))
           param)
          (save-match-data ;; mov reg to reg
            (and (string-match (concat "^mov\s*" reg "\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_reg_to_reg :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; mov mem to reg
            (and (string-match (concat "^mov\s*(" reg ")\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_mem_to_reg :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; mov reg to mem
            (and (string-match (concat "^mov\s*" reg "\s*,\s*(" reg ")\\(.*\\)") param)
                 (return-from ram
                   (append out `(:cmd :mov_reg_to_mem :from ,(match-string 1 param)
                                      :to   ,(match-string 2 param)
                                      :rest ,(match-string 3 param))))))
          (save-match-data ;; jmp reg
            (and (string-match (concat "^jmp\s*" reg "\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :jmp_reg
                                      :to ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          (save-match-data ;; jmp label
            (and (string-match
                  (concat "^jmp\s*" "\\([_a-zA-z]+\\)" "\s?\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :jmp_label
                                      :to ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          (save-match-data ;; label
            (and (string-match
                  (concat "^\\([_a-zA-Z]+\\):" "\s?\\(.*\\)?$") param)
                 (return-from ram
                   (append out `(:cmd :label
                                      :name ,(car (split-string (match-string 1 param)))
                                      :rest ,(match-string 2 param))))))
          ))))

  (mapcar #'(lambda (in) (princ "\n") (prin1 in))
          (mapcar #'p-aasm
                  (split-string arg "\n" nil nil)))
#+END_SRC

#+results: p_aasm
#+begin_example
- ((:empty)
- (:ident 0 :comment-line "# first COMMENT")
- (:ident 2 :comment-line "# COMMENT with indentation")
- (:ident 4 :cmd :mov_reg_to_reg :from "%IPR" :to "%ACR" :rest "     # mov reg to reg")
- (:ident 4 :cmd :mov_reg_to_reg :from "%IPR" :to "%ACR" :rest "")
- (:ident 4 :cmd :mov_mem_to_reg :from "%IPR" :to "%ACR" :rest "   # mov mem to reg")
- (:ident 4 :cmd :mov_mem_to_reg :from "%IPR" :to "%ACR" :rest "")
- (:ident 4 :cmd :mov_reg_to_mem :from "%IPR" :to "%ACR" :rest "   # mov reg to mem")
- (:ident 4 :cmd :mov_reg_to_mem :from "%IPR" :to "%ACR" :rest "")
- (:ident 4 :cmd :jmp_reg :to "%IRP" :rest "           # jmp reg")
- (:ident 4 :cmd :jmp_reg :to "%IRP" :rest "")
- (:ident 4 :cmd :jmp_label :to "_label" :rest "        # jmp label")
- (:ident 4 :cmd :jmp_label :to "_label" :rest "")
- (:ident 0 :cmd :label :name "_label_with_comment" :rest "      # this is label")
- (:ident 0 :cmd :label :name "_label" :rest "")
- (:empty))
#+end_example

* GNU Assembler Producer

Нужен для проверочных целей

#+NAME: gas_producer
#+BEGIN_SRC elisp :var arg=p_aasm :results output
  (defun gas-emit (in)
      (pcase in
        (`(:empty)  "")
        (`(:ident ,idnt :comment-line ,cmnt)
         (princ (format "%s%s\n" (make-string idnt ? ) cmnt)))
        (`(:ident ,idnt :cmd :mov_reg_to_reg :from ,from :to ,to :rest ,rest)
         (princ (format "%smov     %s, %s%s\n" (make-string idnt ? ) from to rest)))
        (`(:ident ,idnt :cmd :mov_mem_to_reg :from ,from :to ,to :rest ,rest)
         (princ (format "%smov     (%s), %s%s\n" (make-string idnt ? ) from to rest)))
        (`(:ident ,idnt :cmd :mov_reg_to_mem :from ,from :to ,to :rest ,rest)
         (princ (format "%smov     %s, (%s)%s\n" (make-string idnt ? ) from to rest)))
        (`(:ident ,idnt :cmd :jmp_reg :to ,to :rest ,rest)
         (princ (format "%sjmp     %s%s\n" (make-string idnt ? ) to rest)))
        (`(:ident ,idnt :cmd :jmp_label :to ,to :rest ,rest)
         (princ (format "%sjmp     %s%s\n" (make-string idnt ? ) to rest)))
        (`(:ident ,idnt :cmd :label :name ,name :rest ,rest)
         (princ (format "%s%s%s\n" (make-string idnt ? ) name rest)))
        (_  (print in))))

  (mapcar #'gas-emit
          (car (read-from-string arg)))
#+END_SRC

#+results: gas_producer
#+begin_example
# first COMMENT
  # COMMENT with indentation
    mov     %IPR, %ACR     # mov reg to reg
    mov     %IPR, %ACR
    mov     (%IPR), %ACR   # mov mem to reg
    mov     (%IPR), %ACR
    mov     %IPR, (%ACR)   # mov reg to mem
    mov     %IPR, (%ACR)
    jmp     %IRP           # jmp reg
    jmp     %IRP
    jmp     _label        # jmp label
    jmp     _label
_label_with_comment      # this is label
_label
#+end_example

* START Opcode Producer

Каждая инструкция (почти) любого процессора имеет некоторый ~требуемый
эффект~, ради которого мы ее применяем. Обычно эффект выражается в
изменении регистров, памяти и флагов процессора.

Часто этот же требуемый эффект может быть достигнут комбинацией других
инструкций. Это дает нам возможность строить эквивалентные программы для
любых целей (оптимизация по скорости и размеру кода, обфускация, и.т.п)

Также у инструкции может быть ~побочный эффект~ (что еще изменяет эта
инструкция, кроме требуемого эффекта). На такие ~побочные эффекты~ можно
наложить ограничения, которые сработают при поиске и выборе нужных
инструкций, когда мы строим программу по эффектам.

Пользуясь данными об эффектах мы можем запустить солвер, чтобы построить
необходимую программу.

Для задачи построения виртуальной машины это не требуется, но если сейчас
заложить несколько вариантов достижения ~требуемых эффектов~, это может
пригодиться для генерализации подхода.

[TODO:gmm] - Написать солвер

** x86_64 Producer

Обычная инструкция на x86_64 имеет переменную длину (до 15 байт) и может
состоять из нескольких компонентов, порядок которых определен:
- Legacy prefixes (1-4 bytes, optional)
- Opcode with prefixes (1-4 bytes, required)
- ModR/M (1 byte, может отсутствовать, если опкод не имеет явных
  операндов)
- SIB (1 byte, для адресации операндов в памяти - может отсутствовать)
- Displacement (1, 2, 4 or 8 bytes, if required)
- Immediate (1, 2, 4 or 8 bytes, if required)

--skiped:https://www.youtube.com/watch?v=CUAXCeRjw3c:--

- Prefixes (REX, VEX : https://habr.com/ru/company/intel/blog/200598/)
  Использование REX позволяет расширить набор регистров r8-r15
ModRM:
- mod[7:6] - 4 метода адресации
  -  11b - register-direct
  - !11b - other addressing
- reg[.R, 5:3] - register-based operand or extend operation encoding
- r/m[.B, 2:0] – register or memory operand when combined with mod field.
- Addressing mode can include a following SIB byte {mod=00b,r/m=101b}

*** mov_reg_to_reg_x86_64

Prefix
- RAX - если нужен
- 0x66 - [TODO:gmm] префикс изменения размера операнда
Opcode:
- 89/r - MOV reg/mem64, reg64 - Move the contents of a 64-bit register to
  a 64-bit destination register or memory operand
- 8B/r - MOV reg64, reg/mem64 - Move the contents of a 64-bit register or
  memory operand to a 64-bit destination register.

ModR/M - [mod:7:6][reg:5:3][r/m:2:0]
mod = 11b - register-direct-addressing mode
reg: register
mem: register

#+NAME: mov_reg_to_reg_x86_64
#+BEGIN_SRC elisp
  (defmacro one-of-them (var &rest vals)
    (let ((acc))
      (dolist (elt vals)
        (push `(equal ,var ,elt) acc))
      (setq acc (reverse acc))
      (push 'or acc)
      acc))

  ;; (macroexpand '(one-of-them reg :%al :%ax :%eax :%rax))

  (defun get-x86-reg (reg)
    "Переводит регистр в биты для mod/rm"
    (let ((acc (block reg
                 (when (one-of-them reg :%al :%ax :%eax :%rax)
                   (return-from reg (list :reg #b000)))
                 (when (one-of-them reg :%cl :%cx :%ecx :%rcx)
                   (return-from reg (list :reg #b001)))
                 (when (one-of-them reg :%dl :%dx :%edx :%edx)
                   (return-from reg (list :reg #b010)))
                 (when (one-of-them reg :%bl :%bx :%ebx :%rbx)
                   (return-from reg (list :reg #b011)))
                 (when (one-of-them reg :%ah :%sp :%esp :%rsp)
                   (return-from reg (list :reg #b100)))
                 (when (one-of-them reg :%ch :%bp :%ebp :%rbp :%bpl)
                   (return-from reg (list :reg #b101)))
                 (when (one-of-them reg :%dh :%si :%esi :%rsi :%sil)
                   (return-from reg (list :reg #b110)))
                 (when (one-of-them reg :%bh :%di :%edi :%rdi :%dil)
                   (return-from reg (list :reg #b111)))
                 (when (one-of-them reg :%r8b :%r8w :%r8d :%r8)
                   (return-from reg (list :reg #b000)))
                 (when (one-of-them reg :%r9b :%r9w :%r9d :%r9)
                   (return-from reg (list :reg #b001 :rex-w 1)))
                 (when (one-of-them reg :%r10b :%r10w :%r10d :%r10)
                   (return-from reg (list :reg #b010 :rex-w 1)))
                 (when (one-of-them reg :%r11b :%r11w :%r11d :%r11)
                   (return-from reg (list :reg #b011 :rex-w 1)))
                 (when (one-of-them reg :%r12b :%r12w :%r12d :%r12)
                   (return-from reg (list :reg #b100 :rex-w 1)))
                 (when (one-of-them reg :%r13b :%r13w :%r13d :%r13)
                   (return-from reg (list :reg #b101 :rex-w 1)))
                 (when (one-of-them reg :%r14b :%r14w :%r14d :%r14)
                   (return-from reg (list :reg #b110 :rex-w 1)))
                 (when (one-of-them reg :%r15b :%r15w :%r15d :%r15)
                   (return-from reg (list :reg #b111 :rex-w 1)))
                 (error "unknown-register"))))
      (when (or (one-of-them reg :%bpl :%sil :%dil)
                (and (null (getf acc :rex-w))
                     (string= ":%r" (substring (symbol-name reg) 0 3))))
        (setf (getf acc :rex-w) 1))
      acc))

  ;; (get-x86-reg :%rsi)


  (defun int-to-binary-string (i)
    "convert an integer into it's binary representation in string format"
    (let ((res ""))
      (while (not (= i 0))
        (setq res (concat (if (= 1 (logand i 1)) "1" "0") res))
        (setq i (lsh i -1)))
      (if (string= res "")
          (setq res "0"))
      res))

  ;; (int-to-binary-string 6)

  (defun get-cmd-plist-x86--mov-reg-to-reg (from to)
    (let ((reg1  (get-x86-reg from))
          (reg2  (get-x86-reg to))
          (rex   nil))
      (cond ((and (plist-member reg1 :rex-w) (plist-member reg2 :rex-w))
             (progn (setf (getf rex :w) t)
                    (setf reg1 (getf reg1 :reg))
                    (setf reg2 (getf reg2 :reg))))
            ((null (or (plist-member reg1 :rex-w) (plist-member reg2 :rex-w)))
             (progn (setf reg1 (getf reg1 :reg))
                    (setf reg2 (getf reg2 :reg))))
            (t (let ((errstr (format "rex-w mismatch %s %s" from to)))
                 (error errstr))))
      (values
       `(:rex ,rex :op #x89 :mod #b11 :reg ,reg1 :mem ,reg2)
       `(:rex ,rex :op #x8B :mod #b11 :reg ,reg2 :mem ,reg1))))

  (get-cmd-plist-x86--mov-reg-to-reg :%esi :%edi)

  (defun cmd-plist-to-bytes (in)
    (let ((acc)
          (rex-plist (getf in :rex))
          (rex #x40))
      ;; rex if needed
      (if (not (null rex-plist))
          (when (getf rex-plist :w)
            (setf rex (logior rex #x8))
            (setf acc (append acc (list rex)))))
      ;; opcode
      (setf acc (append acc (list (getf in :op))))
      ;; modrm
      (let ((modrm 0))
        (setf modrm (ash (getf in :mod) 6))
        (setf modrm (logior modrm (ash (getf in :reg) 3)))
        (setf modrm (logior modrm (getf in :mem)))
        (setf acc (append acc (list modrm))))
      acc))

  ;; (mapcar #'(lambda (in)
  ;;             (format "%X" in))
  ;;         (cmd-plist-to-bytes
  ;;          (cadr (get-cmd-plist-x86--mov-reg-to-reg :%esi :%edi))))
#+END_SRC

#+results: mov_reg_to_reg_x86_64
: cmd-plist-to-bytes

*** TODO je_x86_64

* TODO Elf maker
* TODO Disassembler
